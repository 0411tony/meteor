var fs = require("fs");
var path = require("path");
var _ = require('underscore');
var Future = require('fibers/future');
var Fiber = require('fibers');
var files = require('./files.js');
var watch = require('./watch.js');
var project = require('./project.js');
var bundler = require('./bundler.js');
var release = require('./release.js');
var inFiber = require('./fiber-helpers.js').inFiber;

var RunLog = require('./run-log.js').RunLog;
var Proxy = require('./run-proxy.js').Proxy;
var AppRunner = require('./run-app.js').AppRunner;
var MongoRunner = require('./run-mongo.js').MongoRunner;
var Updater = require('./updater.js').Updater;


///////////////////////////////////////////////////////////////////////////////
// XXX XXX NEXT (if you want to do more):
//
// - make bundler.bundle() not take a release (get it from the app!)
//   - but don't do this until you merge andrew's stuff
// - move mongo shell function from deploy.js into mongo-runner.js
// - possibly fold the mongo restart logic into the mongo-runner.js
// - break each thing out into a separate file.. run-proxy, run-app,
//   run-updater, run-mongo..
// - add warnings to buildmessage, per slava
// - make files.getSettings return errors instead of throwing (or eliminate)
// - mv main.js to meteor.js
///////////////////////////////////////////////////////////////////////////////


// options include: port, buildOptions, settingsFile, banner, program,
// disableOplog, rawLogs
//
// banner can be used to replace the application path that is normally
// printed on startup (appDir) with an arbitrary string, for
// example if you autogenerated an app in a temp file to run tests
var Runner = function (appDir, options) {
  var self = this;
  self.appDir = appDir;

  if (! _.has(options, 'port'))
    throw new Error("no port?");

  self.listenPort = options.port;
  self.appPort = self.listenPort + 1;
  self.mongoPort = self.listenPort + 2;

  // XXX XXX set these in cooperation with MongoRunner

  // Allow override and use of external mongo. Matches code in launch_mongo.
  // XXX make this value be an option, set by command.js from the environment
  self.mongoUrl = process.env.MONGO_URL ||
        ("mongodb://127.0.0.1:" + mongoPort + "/meteor");

  // Allow people to specify an MONGO_OPLOG_URL override. If someone specifies a
  // MONGO_URL but not an MONGO_OPLOG_URL, disable the oplog. If neither is
  // specified, use the default internal mongo oplog.
  self.oplogUrl = undefined;
  if (! options.disableOplog) {
    self.oplogUrl = process.env.MONGO_OPLOG_URL ||
      (process.env.MONGO_URL ? undefined
       : "mongodb://127.0.0.1:" + self.mongoPort + "/local");
  }

  // XXX XXX have this be passed in, not slurped from the environment
  self.rootUrl =
    var rootUrl = process.env.ROOT_URL ||
    ('http://localhost:' + self.listenPort + '/');

  self.banner = options.banner || files.prettyPath(self.appDir);

  self.runLog = new RunLog({
    rawLogs: options.rawLogs
  });

  self.proxy = new Proxy({
    listenPort: self.listenPort,
    proxyToPort: self.appPort,
    runLog: self.runLog,
    onFailure: _.bind(self._failure, self)
  });

  self.mongoRunner = new MongoRunner({
    appDir: self.appDir,
    port: self.mongoPort,
    runLog: self.runLog,
    onFailure: _.bind(self._failure, self)
  });

  self.updater = new Updater;

  self.appRunner = new AppRunner({
    appDir: self.appDir,
    appDirForVersionCheck: options.appDirForVersionCheck,
    port: self.appPort,
    buildOptions: options.buildOptions,
    rootUrl: self.rootUrl,
    settingsFile: options.settingsFile,
    program: options.program,
    proxy: self.proxy,
    runLog: self.runLog
  });
};

_.extend(Runner.prototype, function () {
  // XXX leave a pidfile and check if we are already running
  start: function (onFailure) {
    var self = this;
    self.onFailure = onFailure;
    self.proxy.start();

    // print the banner only once we've successfully bound the port
    process.stdout.write("[[[[[ " + self.banner + " ]]]]]\n\n");

    self.updater.start();
    self.mongoRunner.start();
    self.appRunner.start(_.bind(self._failure), self);
  },

  stop: function () {
    var self = this;
    self.proxy.stop();
    self.updater.stop();
    self.mongoRunner.stop();
    self.appRunner.stop();
  },

  // Just run the application (and all of its supporting processes)
  // until the app process exits for the first time. See
  // AppRunner.runOnce for return value.
  //
  // This is silent.
  runOnce: function () {
    var self = this;

    self.proxy.start();
    self.mongoRunner.start();
    var result = self.appRunner.runOnce();
XXX XXX handle failures
    self.proxy.stop();
    self.mongoRunner.stop();

    return result;
  },

  _failure: function () {
    var self = this;
    if (self.onFailure) {
      // Running via start()
XXX edit call sites to honor
      self.onFailure();
    } else {
      // Running via runOnce()
      XXX XXX
    }
  }
});

// Run the app and all of its associated processes, restarting them if
// they exit, and watching for changes on the source files. Runs (and
// does not return until) an unrecoverable failure happens. Logs to
// stdout.
//
// For argument descriptions, see the Runner constructor.
exports.run = function (appDir, options) {
  var runner = new Runner(appDir, options);
  var fut = new Future;
  runner.start(function () {
    fut['return']();
  });
  fut.wait();
  runner.stop();
};

// As runner.run(), but only runs the app once and does not watch for
// file changes. For return value, see AppRunner.runOnce().
exports.runOnce = function (appDir, options) {
  return (new Runner(appDir, options)).runOnce();
};
